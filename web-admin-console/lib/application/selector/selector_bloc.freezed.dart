// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'selector_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

/// @nodoc
class _$SelectorEventTearOff {
  const _$SelectorEventTearOff();

// ignore: unused_element
  _RolesShowed rolesShowed() {
    return const _RolesShowed();
  }

// ignore: unused_element
  _RightsShowed rightsShowed() {
    return const _RightsShowed();
  }

// ignore: unused_element
  _LoadingStateChanged loadingStateChanged() {
    return const _LoadingStateChanged();
  }

// ignore: unused_element
  _InitRights initRights(List<Right> rights) {
    return _InitRights(
      rights,
    );
  }

// ignore: unused_element
  _RightSelected rightSelected(Right right) {
    return _RightSelected(
      right,
    );
  }

// ignore: unused_element
  _RightDeselected rightDeselected(Right right) {
    return _RightDeselected(
      right,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $SelectorEvent = _$SelectorEventTearOff();

/// @nodoc
mixin _$SelectorEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult rolesShowed(),
    @required TResult rightsShowed(),
    @required TResult loadingStateChanged(),
    @required TResult initRights(List<Right> rights),
    @required TResult rightSelected(Right right),
    @required TResult rightDeselected(Right right),
  });
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult rolesShowed(),
    TResult rightsShowed(),
    TResult loadingStateChanged(),
    TResult initRights(List<Right> rights),
    TResult rightSelected(Right right),
    TResult rightDeselected(Right right),
    @required TResult orElse(),
  });
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult rolesShowed(_RolesShowed value),
    @required TResult rightsShowed(_RightsShowed value),
    @required TResult loadingStateChanged(_LoadingStateChanged value),
    @required TResult initRights(_InitRights value),
    @required TResult rightSelected(_RightSelected value),
    @required TResult rightDeselected(_RightDeselected value),
  });
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult rolesShowed(_RolesShowed value),
    TResult rightsShowed(_RightsShowed value),
    TResult loadingStateChanged(_LoadingStateChanged value),
    TResult initRights(_InitRights value),
    TResult rightSelected(_RightSelected value),
    TResult rightDeselected(_RightDeselected value),
    @required TResult orElse(),
  });
}

/// @nodoc
abstract class $SelectorEventCopyWith<$Res> {
  factory $SelectorEventCopyWith(
          SelectorEvent value, $Res Function(SelectorEvent) then) =
      _$SelectorEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$SelectorEventCopyWithImpl<$Res>
    implements $SelectorEventCopyWith<$Res> {
  _$SelectorEventCopyWithImpl(this._value, this._then);

  final SelectorEvent _value;
  // ignore: unused_field
  final $Res Function(SelectorEvent) _then;
}

/// @nodoc
abstract class _$RolesShowedCopyWith<$Res> {
  factory _$RolesShowedCopyWith(
          _RolesShowed value, $Res Function(_RolesShowed) then) =
      __$RolesShowedCopyWithImpl<$Res>;
}

/// @nodoc
class __$RolesShowedCopyWithImpl<$Res> extends _$SelectorEventCopyWithImpl<$Res>
    implements _$RolesShowedCopyWith<$Res> {
  __$RolesShowedCopyWithImpl(
      _RolesShowed _value, $Res Function(_RolesShowed) _then)
      : super(_value, (v) => _then(v as _RolesShowed));

  @override
  _RolesShowed get _value => super._value as _RolesShowed;
}

/// @nodoc
class _$_RolesShowed with DiagnosticableTreeMixin implements _RolesShowed {
  const _$_RolesShowed();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectorEvent.rolesShowed()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'SelectorEvent.rolesShowed'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _RolesShowed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult rolesShowed(),
    @required TResult rightsShowed(),
    @required TResult loadingStateChanged(),
    @required TResult initRights(List<Right> rights),
    @required TResult rightSelected(Right right),
    @required TResult rightDeselected(Right right),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return rolesShowed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult rolesShowed(),
    TResult rightsShowed(),
    TResult loadingStateChanged(),
    TResult initRights(List<Right> rights),
    TResult rightSelected(Right right),
    TResult rightDeselected(Right right),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (rolesShowed != null) {
      return rolesShowed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult rolesShowed(_RolesShowed value),
    @required TResult rightsShowed(_RightsShowed value),
    @required TResult loadingStateChanged(_LoadingStateChanged value),
    @required TResult initRights(_InitRights value),
    @required TResult rightSelected(_RightSelected value),
    @required TResult rightDeselected(_RightDeselected value),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return rolesShowed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult rolesShowed(_RolesShowed value),
    TResult rightsShowed(_RightsShowed value),
    TResult loadingStateChanged(_LoadingStateChanged value),
    TResult initRights(_InitRights value),
    TResult rightSelected(_RightSelected value),
    TResult rightDeselected(_RightDeselected value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (rolesShowed != null) {
      return rolesShowed(this);
    }
    return orElse();
  }
}

abstract class _RolesShowed implements SelectorEvent {
  const factory _RolesShowed() = _$_RolesShowed;
}

/// @nodoc
abstract class _$RightsShowedCopyWith<$Res> {
  factory _$RightsShowedCopyWith(
          _RightsShowed value, $Res Function(_RightsShowed) then) =
      __$RightsShowedCopyWithImpl<$Res>;
}

/// @nodoc
class __$RightsShowedCopyWithImpl<$Res>
    extends _$SelectorEventCopyWithImpl<$Res>
    implements _$RightsShowedCopyWith<$Res> {
  __$RightsShowedCopyWithImpl(
      _RightsShowed _value, $Res Function(_RightsShowed) _then)
      : super(_value, (v) => _then(v as _RightsShowed));

  @override
  _RightsShowed get _value => super._value as _RightsShowed;
}

/// @nodoc
class _$_RightsShowed with DiagnosticableTreeMixin implements _RightsShowed {
  const _$_RightsShowed();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectorEvent.rightsShowed()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'SelectorEvent.rightsShowed'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _RightsShowed);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult rolesShowed(),
    @required TResult rightsShowed(),
    @required TResult loadingStateChanged(),
    @required TResult initRights(List<Right> rights),
    @required TResult rightSelected(Right right),
    @required TResult rightDeselected(Right right),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return rightsShowed();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult rolesShowed(),
    TResult rightsShowed(),
    TResult loadingStateChanged(),
    TResult initRights(List<Right> rights),
    TResult rightSelected(Right right),
    TResult rightDeselected(Right right),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (rightsShowed != null) {
      return rightsShowed();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult rolesShowed(_RolesShowed value),
    @required TResult rightsShowed(_RightsShowed value),
    @required TResult loadingStateChanged(_LoadingStateChanged value),
    @required TResult initRights(_InitRights value),
    @required TResult rightSelected(_RightSelected value),
    @required TResult rightDeselected(_RightDeselected value),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return rightsShowed(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult rolesShowed(_RolesShowed value),
    TResult rightsShowed(_RightsShowed value),
    TResult loadingStateChanged(_LoadingStateChanged value),
    TResult initRights(_InitRights value),
    TResult rightSelected(_RightSelected value),
    TResult rightDeselected(_RightDeselected value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (rightsShowed != null) {
      return rightsShowed(this);
    }
    return orElse();
  }
}

abstract class _RightsShowed implements SelectorEvent {
  const factory _RightsShowed() = _$_RightsShowed;
}

/// @nodoc
abstract class _$LoadingStateChangedCopyWith<$Res> {
  factory _$LoadingStateChangedCopyWith(_LoadingStateChanged value,
          $Res Function(_LoadingStateChanged) then) =
      __$LoadingStateChangedCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadingStateChangedCopyWithImpl<$Res>
    extends _$SelectorEventCopyWithImpl<$Res>
    implements _$LoadingStateChangedCopyWith<$Res> {
  __$LoadingStateChangedCopyWithImpl(
      _LoadingStateChanged _value, $Res Function(_LoadingStateChanged) _then)
      : super(_value, (v) => _then(v as _LoadingStateChanged));

  @override
  _LoadingStateChanged get _value => super._value as _LoadingStateChanged;
}

/// @nodoc
class _$_LoadingStateChanged
    with DiagnosticableTreeMixin
    implements _LoadingStateChanged {
  const _$_LoadingStateChanged();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectorEvent.loadingStateChanged()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SelectorEvent.loadingStateChanged'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoadingStateChanged);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult rolesShowed(),
    @required TResult rightsShowed(),
    @required TResult loadingStateChanged(),
    @required TResult initRights(List<Right> rights),
    @required TResult rightSelected(Right right),
    @required TResult rightDeselected(Right right),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return loadingStateChanged();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult rolesShowed(),
    TResult rightsShowed(),
    TResult loadingStateChanged(),
    TResult initRights(List<Right> rights),
    TResult rightSelected(Right right),
    TResult rightDeselected(Right right),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadingStateChanged != null) {
      return loadingStateChanged();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult rolesShowed(_RolesShowed value),
    @required TResult rightsShowed(_RightsShowed value),
    @required TResult loadingStateChanged(_LoadingStateChanged value),
    @required TResult initRights(_InitRights value),
    @required TResult rightSelected(_RightSelected value),
    @required TResult rightDeselected(_RightDeselected value),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return loadingStateChanged(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult rolesShowed(_RolesShowed value),
    TResult rightsShowed(_RightsShowed value),
    TResult loadingStateChanged(_LoadingStateChanged value),
    TResult initRights(_InitRights value),
    TResult rightSelected(_RightSelected value),
    TResult rightDeselected(_RightDeselected value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (loadingStateChanged != null) {
      return loadingStateChanged(this);
    }
    return orElse();
  }
}

abstract class _LoadingStateChanged implements SelectorEvent {
  const factory _LoadingStateChanged() = _$_LoadingStateChanged;
}

/// @nodoc
abstract class _$InitRightsCopyWith<$Res> {
  factory _$InitRightsCopyWith(
          _InitRights value, $Res Function(_InitRights) then) =
      __$InitRightsCopyWithImpl<$Res>;
  $Res call({List<Right> rights});
}

/// @nodoc
class __$InitRightsCopyWithImpl<$Res> extends _$SelectorEventCopyWithImpl<$Res>
    implements _$InitRightsCopyWith<$Res> {
  __$InitRightsCopyWithImpl(
      _InitRights _value, $Res Function(_InitRights) _then)
      : super(_value, (v) => _then(v as _InitRights));

  @override
  _InitRights get _value => super._value as _InitRights;

  @override
  $Res call({
    Object rights = freezed,
  }) {
    return _then(_InitRights(
      rights == freezed ? _value.rights : rights as List<Right>,
    ));
  }
}

/// @nodoc
class _$_InitRights with DiagnosticableTreeMixin implements _InitRights {
  const _$_InitRights(this.rights) : assert(rights != null);

  @override
  final List<Right> rights;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectorEvent.initRights(rights: $rights)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SelectorEvent.initRights'))
      ..add(DiagnosticsProperty('rights', rights));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _InitRights &&
            (identical(other.rights, rights) ||
                const DeepCollectionEquality().equals(other.rights, rights)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(rights);

  @JsonKey(ignore: true)
  @override
  _$InitRightsCopyWith<_InitRights> get copyWith =>
      __$InitRightsCopyWithImpl<_InitRights>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult rolesShowed(),
    @required TResult rightsShowed(),
    @required TResult loadingStateChanged(),
    @required TResult initRights(List<Right> rights),
    @required TResult rightSelected(Right right),
    @required TResult rightDeselected(Right right),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return initRights(rights);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult rolesShowed(),
    TResult rightsShowed(),
    TResult loadingStateChanged(),
    TResult initRights(List<Right> rights),
    TResult rightSelected(Right right),
    TResult rightDeselected(Right right),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initRights != null) {
      return initRights(rights);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult rolesShowed(_RolesShowed value),
    @required TResult rightsShowed(_RightsShowed value),
    @required TResult loadingStateChanged(_LoadingStateChanged value),
    @required TResult initRights(_InitRights value),
    @required TResult rightSelected(_RightSelected value),
    @required TResult rightDeselected(_RightDeselected value),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return initRights(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult rolesShowed(_RolesShowed value),
    TResult rightsShowed(_RightsShowed value),
    TResult loadingStateChanged(_LoadingStateChanged value),
    TResult initRights(_InitRights value),
    TResult rightSelected(_RightSelected value),
    TResult rightDeselected(_RightDeselected value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (initRights != null) {
      return initRights(this);
    }
    return orElse();
  }
}

abstract class _InitRights implements SelectorEvent {
  const factory _InitRights(List<Right> rights) = _$_InitRights;

  List<Right> get rights;
  @JsonKey(ignore: true)
  _$InitRightsCopyWith<_InitRights> get copyWith;
}

/// @nodoc
abstract class _$RightSelectedCopyWith<$Res> {
  factory _$RightSelectedCopyWith(
          _RightSelected value, $Res Function(_RightSelected) then) =
      __$RightSelectedCopyWithImpl<$Res>;
  $Res call({Right right});

  $RightCopyWith<$Res> get right;
}

/// @nodoc
class __$RightSelectedCopyWithImpl<$Res>
    extends _$SelectorEventCopyWithImpl<$Res>
    implements _$RightSelectedCopyWith<$Res> {
  __$RightSelectedCopyWithImpl(
      _RightSelected _value, $Res Function(_RightSelected) _then)
      : super(_value, (v) => _then(v as _RightSelected));

  @override
  _RightSelected get _value => super._value as _RightSelected;

  @override
  $Res call({
    Object right = freezed,
  }) {
    return _then(_RightSelected(
      right == freezed ? _value.right : right as Right,
    ));
  }

  @override
  $RightCopyWith<$Res> get right {
    if (_value.right == null) {
      return null;
    }
    return $RightCopyWith<$Res>(_value.right, (value) {
      return _then(_value.copyWith(right: value));
    });
  }
}

/// @nodoc
class _$_RightSelected with DiagnosticableTreeMixin implements _RightSelected {
  const _$_RightSelected(this.right) : assert(right != null);

  @override
  final Right right;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectorEvent.rightSelected(right: $right)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SelectorEvent.rightSelected'))
      ..add(DiagnosticsProperty('right', right));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RightSelected &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(right);

  @JsonKey(ignore: true)
  @override
  _$RightSelectedCopyWith<_RightSelected> get copyWith =>
      __$RightSelectedCopyWithImpl<_RightSelected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult rolesShowed(),
    @required TResult rightsShowed(),
    @required TResult loadingStateChanged(),
    @required TResult initRights(List<Right> rights),
    @required TResult rightSelected(Right right),
    @required TResult rightDeselected(Right right),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return rightSelected(right);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult rolesShowed(),
    TResult rightsShowed(),
    TResult loadingStateChanged(),
    TResult initRights(List<Right> rights),
    TResult rightSelected(Right right),
    TResult rightDeselected(Right right),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (rightSelected != null) {
      return rightSelected(right);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult rolesShowed(_RolesShowed value),
    @required TResult rightsShowed(_RightsShowed value),
    @required TResult loadingStateChanged(_LoadingStateChanged value),
    @required TResult initRights(_InitRights value),
    @required TResult rightSelected(_RightSelected value),
    @required TResult rightDeselected(_RightDeselected value),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return rightSelected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult rolesShowed(_RolesShowed value),
    TResult rightsShowed(_RightsShowed value),
    TResult loadingStateChanged(_LoadingStateChanged value),
    TResult initRights(_InitRights value),
    TResult rightSelected(_RightSelected value),
    TResult rightDeselected(_RightDeselected value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (rightSelected != null) {
      return rightSelected(this);
    }
    return orElse();
  }
}

abstract class _RightSelected implements SelectorEvent {
  const factory _RightSelected(Right right) = _$_RightSelected;

  Right get right;
  @JsonKey(ignore: true)
  _$RightSelectedCopyWith<_RightSelected> get copyWith;
}

/// @nodoc
abstract class _$RightDeselectedCopyWith<$Res> {
  factory _$RightDeselectedCopyWith(
          _RightDeselected value, $Res Function(_RightDeselected) then) =
      __$RightDeselectedCopyWithImpl<$Res>;
  $Res call({Right right});

  $RightCopyWith<$Res> get right;
}

/// @nodoc
class __$RightDeselectedCopyWithImpl<$Res>
    extends _$SelectorEventCopyWithImpl<$Res>
    implements _$RightDeselectedCopyWith<$Res> {
  __$RightDeselectedCopyWithImpl(
      _RightDeselected _value, $Res Function(_RightDeselected) _then)
      : super(_value, (v) => _then(v as _RightDeselected));

  @override
  _RightDeselected get _value => super._value as _RightDeselected;

  @override
  $Res call({
    Object right = freezed,
  }) {
    return _then(_RightDeselected(
      right == freezed ? _value.right : right as Right,
    ));
  }

  @override
  $RightCopyWith<$Res> get right {
    if (_value.right == null) {
      return null;
    }
    return $RightCopyWith<$Res>(_value.right, (value) {
      return _then(_value.copyWith(right: value));
    });
  }
}

/// @nodoc
class _$_RightDeselected
    with DiagnosticableTreeMixin
    implements _RightDeselected {
  const _$_RightDeselected(this.right) : assert(right != null);

  @override
  final Right right;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectorEvent.rightDeselected(right: $right)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SelectorEvent.rightDeselected'))
      ..add(DiagnosticsProperty('right', right));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _RightDeselected &&
            (identical(other.right, right) ||
                const DeepCollectionEquality().equals(other.right, right)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(right);

  @JsonKey(ignore: true)
  @override
  _$RightDeselectedCopyWith<_RightDeselected> get copyWith =>
      __$RightDeselectedCopyWithImpl<_RightDeselected>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object>({
    @required TResult rolesShowed(),
    @required TResult rightsShowed(),
    @required TResult loadingStateChanged(),
    @required TResult initRights(List<Right> rights),
    @required TResult rightSelected(Right right),
    @required TResult rightDeselected(Right right),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return rightDeselected(right);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object>({
    TResult rolesShowed(),
    TResult rightsShowed(),
    TResult loadingStateChanged(),
    TResult initRights(List<Right> rights),
    TResult rightSelected(Right right),
    TResult rightDeselected(Right right),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (rightDeselected != null) {
      return rightDeselected(right);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object>({
    @required TResult rolesShowed(_RolesShowed value),
    @required TResult rightsShowed(_RightsShowed value),
    @required TResult loadingStateChanged(_LoadingStateChanged value),
    @required TResult initRights(_InitRights value),
    @required TResult rightSelected(_RightSelected value),
    @required TResult rightDeselected(_RightDeselected value),
  }) {
    assert(rolesShowed != null);
    assert(rightsShowed != null);
    assert(loadingStateChanged != null);
    assert(initRights != null);
    assert(rightSelected != null);
    assert(rightDeselected != null);
    return rightDeselected(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object>({
    TResult rolesShowed(_RolesShowed value),
    TResult rightsShowed(_RightsShowed value),
    TResult loadingStateChanged(_LoadingStateChanged value),
    TResult initRights(_InitRights value),
    TResult rightSelected(_RightSelected value),
    TResult rightDeselected(_RightDeselected value),
    @required TResult orElse(),
  }) {
    assert(orElse != null);
    if (rightDeselected != null) {
      return rightDeselected(this);
    }
    return orElse();
  }
}

abstract class _RightDeselected implements SelectorEvent {
  const factory _RightDeselected(Right right) = _$_RightDeselected;

  Right get right;
  @JsonKey(ignore: true)
  _$RightDeselectedCopyWith<_RightDeselected> get copyWith;
}

/// @nodoc
class _$SelectorStateTearOff {
  const _$SelectorStateTearOff();

// ignore: unused_element
  _SelectorState call(
      {@required SelectorMenu menu,
      @required bool isLoading,
      @required List<Right> selectedRights}) {
    return _SelectorState(
      menu: menu,
      isLoading: isLoading,
      selectedRights: selectedRights,
    );
  }
}

/// @nodoc
// ignore: unused_element
const $SelectorState = _$SelectorStateTearOff();

/// @nodoc
mixin _$SelectorState {
  SelectorMenu get menu;
  bool get isLoading;
  List<Right> get selectedRights;

  @JsonKey(ignore: true)
  $SelectorStateCopyWith<SelectorState> get copyWith;
}

/// @nodoc
abstract class $SelectorStateCopyWith<$Res> {
  factory $SelectorStateCopyWith(
          SelectorState value, $Res Function(SelectorState) then) =
      _$SelectorStateCopyWithImpl<$Res>;
  $Res call({SelectorMenu menu, bool isLoading, List<Right> selectedRights});
}

/// @nodoc
class _$SelectorStateCopyWithImpl<$Res>
    implements $SelectorStateCopyWith<$Res> {
  _$SelectorStateCopyWithImpl(this._value, this._then);

  final SelectorState _value;
  // ignore: unused_field
  final $Res Function(SelectorState) _then;

  @override
  $Res call({
    Object menu = freezed,
    Object isLoading = freezed,
    Object selectedRights = freezed,
  }) {
    return _then(_value.copyWith(
      menu: menu == freezed ? _value.menu : menu as SelectorMenu,
      isLoading: isLoading == freezed ? _value.isLoading : isLoading as bool,
      selectedRights: selectedRights == freezed
          ? _value.selectedRights
          : selectedRights as List<Right>,
    ));
  }
}

/// @nodoc
abstract class _$SelectorStateCopyWith<$Res>
    implements $SelectorStateCopyWith<$Res> {
  factory _$SelectorStateCopyWith(
          _SelectorState value, $Res Function(_SelectorState) then) =
      __$SelectorStateCopyWithImpl<$Res>;
  @override
  $Res call({SelectorMenu menu, bool isLoading, List<Right> selectedRights});
}

/// @nodoc
class __$SelectorStateCopyWithImpl<$Res>
    extends _$SelectorStateCopyWithImpl<$Res>
    implements _$SelectorStateCopyWith<$Res> {
  __$SelectorStateCopyWithImpl(
      _SelectorState _value, $Res Function(_SelectorState) _then)
      : super(_value, (v) => _then(v as _SelectorState));

  @override
  _SelectorState get _value => super._value as _SelectorState;

  @override
  $Res call({
    Object menu = freezed,
    Object isLoading = freezed,
    Object selectedRights = freezed,
  }) {
    return _then(_SelectorState(
      menu: menu == freezed ? _value.menu : menu as SelectorMenu,
      isLoading: isLoading == freezed ? _value.isLoading : isLoading as bool,
      selectedRights: selectedRights == freezed
          ? _value.selectedRights
          : selectedRights as List<Right>,
    ));
  }
}

/// @nodoc
class _$_SelectorState with DiagnosticableTreeMixin implements _SelectorState {
  const _$_SelectorState(
      {@required this.menu,
      @required this.isLoading,
      @required this.selectedRights})
      : assert(menu != null),
        assert(isLoading != null),
        assert(selectedRights != null);

  @override
  final SelectorMenu menu;
  @override
  final bool isLoading;
  @override
  final List<Right> selectedRights;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'SelectorState(menu: $menu, isLoading: $isLoading, selectedRights: $selectedRights)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'SelectorState'))
      ..add(DiagnosticsProperty('menu', menu))
      ..add(DiagnosticsProperty('isLoading', isLoading))
      ..add(DiagnosticsProperty('selectedRights', selectedRights));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SelectorState &&
            (identical(other.menu, menu) ||
                const DeepCollectionEquality().equals(other.menu, menu)) &&
            (identical(other.isLoading, isLoading) ||
                const DeepCollectionEquality()
                    .equals(other.isLoading, isLoading)) &&
            (identical(other.selectedRights, selectedRights) ||
                const DeepCollectionEquality()
                    .equals(other.selectedRights, selectedRights)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(menu) ^
      const DeepCollectionEquality().hash(isLoading) ^
      const DeepCollectionEquality().hash(selectedRights);

  @JsonKey(ignore: true)
  @override
  _$SelectorStateCopyWith<_SelectorState> get copyWith =>
      __$SelectorStateCopyWithImpl<_SelectorState>(this, _$identity);
}

abstract class _SelectorState implements SelectorState {
  const factory _SelectorState(
      {@required SelectorMenu menu,
      @required bool isLoading,
      @required List<Right> selectedRights}) = _$_SelectorState;

  @override
  SelectorMenu get menu;
  @override
  bool get isLoading;
  @override
  List<Right> get selectedRights;
  @override
  @JsonKey(ignore: true)
  _$SelectorStateCopyWith<_SelectorState> get copyWith;
}
